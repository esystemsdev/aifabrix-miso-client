# Authentication API Reference

Complete API reference for authentication methods in the MisoClient SDK.

## Table of Contents

- [Login](#login)
- [Logout](#logout)
- [Token Validation](#token-validation)
- [User Information](#user-information)
- [Authentication Strategy](#authentication-strategy)
- [Type Definitions](#type-definitions)
- [Examples](#examples)
- [See Also](#see-also)

## Login

### `login(params: { redirect: string; state?: string }): Promise<LoginResponse>`

Initiates the login flow by calling the controller API. Returns the login URL and state for browser redirect or manual navigation.

**Important:** Your application only needs to know about your own app URLs and the miso-controller. The miso-controller manages all authentication flows internally, including OAuth callbacks with Keycloak. You don't need to handle OAuth callbacks in your application.

**Security Advantages:**

This approach is more secure than traditional OAuth implementations because:

- **Authenticated Redirect Requests**: Every `login()` request is authenticated with your app's client credentials (via `x-client-token` header). The controller knows which app is making the request, making it very difficult to use wrong redirect URLs.
- **Controller-Side Validation**: The controller validates redirect URLs against your registered app domains. Only URLs belonging to your registered application are allowed.
- **Prevents Open Redirect Attacks**: Attackers cannot request arbitrary redirects because they need valid app credentials. Even if they intercept a redirect URL, they cannot change it because the controller validates it server-side.
- **No Unauthenticated Requests**: Unlike traditional OAuth flows where redirect URLs may be passed unauthenticated, all redirect requests here require valid client credentials.

**Parameters:**

- `params.redirect` - Required final destination URL in your application where the user should be redirected after successful authentication. This is a URL in your app (e.g., `https://myapp.com/dashboard` or `https://myapp.com/home`). The miso-controller handles the OAuth callback internally and then redirects the user to this URL. The controller validates this URL against your registered app domains.
- `params.state` - Optional CSRF protection token (auto-generated by controller if omitted)

**Returns:** Promise resolving to `LoginResponse` with `loginUrl` (the Keycloak authentication URL) and `state`

**How it works:**

1. Your app calls `login()` with your final destination URL (request is authenticated with client credentials)
2. Controller validates the redirect URL against your registered app domains
3. Controller returns a `loginUrl` (Keycloak authentication URL)
4. User is redirected to `loginUrl` to authenticate with Keycloak
5. Keycloak redirects to the controller's callback endpoint (handled internally by controller)
6. Controller processes authentication and redirects user to your validated `redirect` URL
7. User arrives at your app's final destination URL

**Example:**

```typescript
// In browser environment - redirect user to dashboard after login
const response = await client.login({ redirect: 'https://myapp.com/dashboard' });
window.location.href = response.data.loginUrl;
// After authentication, controller redirects to https://myapp.com/dashboard

// With custom state for CSRF protection
const state = 'custom-csrf-token-123';
const response = await client.login({ 
  redirect: 'https://myapp.com/home', // Final destination in your app
  state: state
});
window.location.href = response.data.loginUrl;

// Return to current page after login
const response = await client.login({ redirect: window.location.href });
window.location.href = response.data.loginUrl;

// In Node.js environment - return URL for manual navigation
const response = await client.login({ redirect: 'https://myapp.com/dashboard' });
console.log('Login URL:', response.data.loginUrl);
console.log('State:', response.data.state);
```

## Logout

### `logout(params: { token: string }): Promise<LogoutResponse>`

Logs out the current user by invalidating their access token. Automatically clears token validation cache for the user.

**Parameters:**

- `params.token` - Access token to invalidate

**Returns:** Promise resolving to `LogoutResponse` with success message

**Cache Invalidation:**

- Token validation cache is automatically cleared on logout
- Cache key format: `token:${userId}` (userId extracted from JWT token)
- Cache clearing happens even if logout API call fails (idempotent behavior)
- Ensures user cannot use cached validation results after logout

**Example:**

```typescript
// Extract token from request
const token = client.getToken(req);

// Logout user (automatically clears token cache)
const response = await client.logout({ token });
console.log('Logout message:', response.message);

// In Express middleware
app.post('/logout', async (req, res) => {
  const token = client.getToken(req);
  if (!token) {
    return res.status(401).json({ error: 'No token provided' });
  }
  
  try {
    const result = await client.logout({ token });
    res.json({ message: result.message });
  } catch (error) {
    res.status(500).json({ error: 'Logout failed' });
  }
});
```

## Token Validation

### `validateToken(token: string, authStrategy?: AuthStrategy): Promise<boolean>`

Validates a JWT token with the controller. Results are cached by userId with a configurable TTL (default: 15 minutes) to reduce API calls.

**Parameters:**

- `token` - JWT token to validate
- `authStrategy` - Optional authentication strategy override

**Returns:** Promise resolving to `true` if token is valid, `false` otherwise

**Caching Behavior:**

- Token validation results are cached by userId (extracted from JWT)
- Cache key format: `token:${userId}`
- Default TTL: 900 seconds (15 minutes), configurable via `config.cache.tokenValidationTTL`
- Cache is automatically cleared on logout
- Falls back to controller API call if cache is unavailable or expired

**Example:**

```typescript
const isValid = await client.validateToken(userToken);
if (isValid) {
  console.log('Token is valid');
}

// With custom auth strategy
const strategy = client.createAuthStrategy(['bearer', 'api-key'], userToken, 'api-key-123');
const isValid = await client.validateToken(userToken, strategy);
```

### `isAuthenticated(token: string, authStrategy?: AuthStrategy): Promise<boolean>`

Checks if a user is authenticated (alias for `validateToken`).

**Parameters:**

- `token` - JWT token
- `authStrategy` - Optional authentication strategy override

**Returns:** Promise resolving to `true` if authenticated, `false` otherwise

**Example:**

```typescript
const isAuth = await client.isAuthenticated(token);
```

## Token Refresh

### `refreshToken(refreshToken: string, authStrategy?: AuthStrategy): Promise<RefreshTokenResponse | null>`

Refreshes a user access token using a refresh token. Exchanges the refresh token for a new access token and refresh token pair.

**Parameters:**

- `refreshToken` - Refresh token to exchange for new access token
- `authStrategy` - Optional authentication strategy override

**Returns:** Promise resolving to `RefreshTokenResponse` with new tokens and expiration info, or `null` on error

**Response:**

```typescript
interface RefreshTokenResponse {
  success: boolean;
  accessToken: string;
  refreshToken: string;
  expiresIn: number;
  expiresAt?: string; // ISO date string
  timestamp?: string;
}
```

**Example:**

```typescript
// Backend: Refresh token
const response = await client.refreshToken(refreshToken);
if (response) {
  console.log('New access token:', response.accessToken);
  console.log('Expires in:', response.expiresIn, 'seconds');
}

// With custom auth strategy
const strategy = client.createAuthStrategy(['client-token']);
const response = await client.refreshToken(refreshToken, strategy);
```

**Error Handling:**

- Returns `null` on error (network errors, invalid token, expired token)
- Errors are logged with correlation IDs for tracking
- Does not throw exceptions - always returns `null` or `RefreshTokenResponse`

## User Information

### `getUser(token: string, authStrategy?: AuthStrategy): Promise<UserInfo | null>`

Retrieves user information from a valid token.

**Parameters:**

- `token` - JWT token
- `authStrategy` - Optional authentication strategy override

**Returns:** Promise resolving to user information or `null` if invalid

**Example:**

```typescript
const user = await client.getUser(token);
if (user) {
  console.log(`Welcome, ${user.username}!`);
}

// With custom auth strategy
const strategy = client.createAuthStrategy(['client-token']);
const user = await client.getUser(token, strategy);
```

## Authentication Strategy

### `requestWithAuthStrategy<T>(method: 'GET' | 'POST' | 'PUT' | 'DELETE', url: string, authStrategy: AuthStrategy, data?: unknown, config?: AxiosRequestConfig): Promise<T>`

Makes an HTTP request with a custom authentication strategy. Tries authentication methods in priority order based on the strategy.

**Parameters:**

- `method` - HTTP method (GET, POST, PUT, DELETE)
- `url` - Request URL
- `authStrategy` - Authentication strategy configuration
- `data` - Optional request data (for POST/PUT)
- `config` - Optional Axios request configuration

**Returns:** Promise resolving to response data

**Example:**

```typescript
// Use client-token only
const strategy = client.createAuthStrategy(['client-token']);
const data = await client.requestWithAuthStrategy('GET', '/api/data', strategy);

// Use bearer token with fallback to client-token
const strategy2 = client.createAuthStrategy(['bearer', 'client-token'], 'bearer-token-123');
const result = await client.requestWithAuthStrategy('POST', '/api/create', strategy2, { name: 'test' });
```

### `createAuthStrategy(methods: ('bearer' | 'client-token' | 'client-credentials' | 'api-key')[], bearerToken?: string, apiKey?: string): AuthStrategy`

Creates an authentication strategy with specified methods and credentials.

**Parameters:**

- `methods` - Array of authentication methods in priority order
- `bearerToken` - Optional bearer token for bearer authentication
- `apiKey` - Optional API key for api-key authentication

**Returns:** Authentication strategy object

**Example:**

```typescript
// Bearer token with fallback to client-token
const strategy = client.createAuthStrategy(['bearer', 'client-token'], 'token-123');

// API key with fallback to client-credentials
const strategy2 = client.createAuthStrategy(['api-key', 'client-credentials'], undefined, 'api-key-456');

// Client-token only
const strategy3 = client.createAuthStrategy(['client-token']);
```

### `getDefaultAuthStrategy(bearerToken?: string): AuthStrategy`

Gets the default authentication strategy (bearer token with fallback to client-token).

**Parameters:**

- `bearerToken` - Optional bearer token

**Returns:** Default authentication strategy

**Example:**

```typescript
const defaultStrategy = client.getDefaultAuthStrategy(token);
// Returns: { methods: ['bearer', 'client-token'], bearerToken: token }

// Use with existing methods
const roles = await client.getRoles(token, defaultStrategy);
```

## Type Definitions

### `AuthStrategy`

Interface for configuring authentication strategy.

```typescript
interface AuthStrategy {
  methods: AuthMethod[]; // Array of authentication methods in priority order
  bearerToken?: string;  // Optional bearer token for bearer authentication
  apiKey?: string;       // Optional API key for api-key authentication
}
```

**Supported Methods:**

- `'bearer'` - Bearer token authentication (Authorization: Bearer `token`)
- `'client-token'` - Client token authentication (x-client-token header)
- `'client-credentials'` - Client credentials authentication (x-client-id and x-client-secret headers)
- `'api-key'` - API key authentication (Authorization: Bearer `api-key`)

**Priority-Based Fallback:** Methods are tried in the order specified in the `methods` array until one succeeds.

**Example:**

```typescript
// Global strategy configuration
const client = new MisoClient({
  ...loadConfig(),
  authStrategy: {
    methods: ['bearer', 'client-token', 'client-credentials'],
    bearerToken: 'optional-default-token'
  }
});

// Per-request strategy
const strategy: AuthStrategy = {
  methods: ['api-key', 'client-token'],
  apiKey: 'my-api-key'
};
await client.getRoles(token, strategy);
```

### `AuthMethod`

Type for authentication method names.

```typescript
type AuthMethod = 'bearer' | 'client-token' | 'client-credentials' | 'api-key';
```

### `LoginResponse`

Login response interface returned by the `login()` method.

```typescript
interface LoginResponse {
  success: boolean; // Whether the login request was successful
  data: {
    loginUrl: string; // URL to redirect user to for authentication
    state: string; // CSRF protection token
  };
  timestamp: string; // ISO timestamp of the response
}
```

### `LogoutResponse`

Logout response interface returned by the `logout()` method.

```typescript
interface LogoutResponse {
  success: boolean; // Whether the logout was successful
  message: string; // Success message
  timestamp: string; // ISO timestamp of the response
}
```

### `RefreshTokenResponse`

Refresh token response interface returned by the `refreshToken()` method.

```typescript
interface RefreshTokenResponse {
  success: boolean; // Whether the refresh was successful
  accessToken: string; // New access token
  refreshToken: string; // New refresh token
  expiresIn: number; // Token expiration time in seconds
  expiresAt?: string; // ISO date string for expiration
  timestamp?: string; // ISO timestamp of the response
}
```

### `UserInfo`

User information interface.

```typescript
interface UserInfo {
  id: string; // User ID
  username: string; // Username
  email?: string; // Optional: Email address
  firstName?: string; // Optional: First name
  lastName?: string; // Optional: Last name
  roles?: string[]; // Optional: User roles
}
```

For complete type definitions, see [Type Reference](./reference-types.md).

## Examples

### Express Authentication Middleware

```typescript
import express from 'express';
import { MisoClient, loadConfig } from '@aifabrix/miso-client';

const app = express();
const client = new MisoClient(loadConfig());
await client.initialize();

export async function authMiddleware(
  req: express.Request,
  res: express.Response,
  next: express.NextFunction
) {
  try {
    const token = client.getToken(req);

    if (!token) {
      return res.status(401).json({ error: 'No token provided' });
    }

    const isValid = await client.validateToken(token);
    if (!isValid) {
      return res.status(401).json({ error: 'Invalid token' });
    }

    const user = await client.getUser(token);
    req.user = user;
    next();
  } catch (error) {
    await client.log.error('Authentication middleware error', {
      error: error instanceof Error ? error.message : 'Unknown error',
      path: req.path,
      method: req.method
    });
    res.status(500).json({ error: 'Internal server error' });
  }
}

// Usage
app.get('/protected', authMiddleware, (req, res) => {
  res.json({ message: 'Hello authenticated user!', user: req.user });
});
```

### React Authentication Context

```typescript
// AuthContext.tsx
import React, { createContext, useContext, useEffect, useState } from 'react';
import { MisoClient, loadConfig, UserInfo } from '@aifabrix/miso-client';

interface AuthContextType {
  user: UserInfo | null;
  isAuthenticated: boolean;
  isLoading: boolean;
  login: () => void;
  logout: () => void;
}

const AuthContext = createContext<AuthContextType | null>(null);

export function AuthProvider({ children }: { children: React.ReactNode }) {
  const [user, setUser] = useState<UserInfo | null>(null);
  const [isAuthenticated, setIsAuthenticated] = useState(false);
  const [isLoading, setIsLoading] = useState(true);
  const [client] = useState(() => new MisoClient(loadConfig()));

  useEffect(() => {
    const initAuth = async () => {
      try {
        await client.initialize();

        const token = localStorage.getItem('auth_token');
        if (token) {
          const isValid = await client.validateToken(token);
          if (isValid) {
            const userInfo = await client.getUser(token);
            setUser(userInfo);
            setIsAuthenticated(true);
          } else {
            localStorage.removeItem('auth_token');
          }
        }
      } catch (error) {
        console.error('Auth initialization failed:', error);
      } finally {
        setIsLoading(false);
      }
    };

    initAuth();
  }, [client]);

  const login = async () => {
    try {
      const response = await client.login({ redirect: 'https://myapp.com/dashboard' });
      window.location.href = response.data.loginUrl;
    } catch (error) {
      console.error('Login error:', error);
    }
  };

  const logout = async () => {
    try {
      const token = localStorage.getItem('auth_token');
      if (token) {
        await client.logout({ token });
      }
    } catch (error) {
      console.error('Logout error:', error);
    } finally {
      localStorage.removeItem('auth_token');
      setUser(null);
      setIsAuthenticated(false);
    }
  };

  return (
    <AuthContext.Provider value={{
      user,
      isAuthenticated,
      isLoading,
      login,
      logout,
    }}>
      {children}
    </AuthContext.Provider>
  );
}

export function useAuth() {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
}
```

### Next.js API Routes

```typescript
// pages/api/posts.ts
import { NextApiRequest, NextApiResponse } from 'next';
import { MisoClient, loadConfig } from '@aifabrix/miso-client';

const client = new MisoClient(loadConfig());
await client.initialize();

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  try {
    const token = client.getToken(req);

    if (!token) {
      return res.status(401).json({ error: 'No token provided' });
    }

    const isValid = await client.validateToken(token);
    if (!isValid) {
      return res.status(401).json({ error: 'Invalid token' });
    }

    const user = await client.getUser(token);

    switch (req.method) {
      case 'GET':
        await client.log.info('Posts fetched', { userId: user?.id });
        return res.status(200).json({ posts: [] });

      default:
        return res.status(405).json({ error: 'Method not allowed' });
    }
  } catch (error) {
    await client.log.error('API error', {
      error: error instanceof Error ? error.message : 'Unknown error',
      method: req.method,
      path: req.url
    });
    return res.status(500).json({ error: 'Internal server error' });
  }
}
```

### NestJS Guards

```typescript
// auth.guard.ts
import { Injectable, CanActivate, ExecutionContext, UnauthorizedException } from '@nestjs/common';
import { MisoClient, loadConfig } from '@aifabrix/miso-client';

@Injectable()
export class AuthGuard implements CanActivate {
  private client: MisoClient;

  constructor() {
    this.client = new MisoClient(loadConfig());
    this.client.initialize();
  }

  async canActivate(context: ExecutionContext): Promise<boolean> {
    const request = context.switchToHttp().getRequest();
    const token = request.headers.authorization?.replace('Bearer ', '');

    if (!token) {
      throw new UnauthorizedException('No token provided');
    }

    try {
      const isValid = await this.client.validateToken(token);
      if (!isValid) {
        throw new UnauthorizedException('Invalid token');
      }

      const user = await this.client.getUser(token);
      request.user = user;
      return true;
    } catch (error) {
      await this.client.log.error('Authentication failed', {
        error: error instanceof Error ? error.message : 'Unknown error',
        path: request.url
      });
      throw new UnauthorizedException('Authentication failed');
    }
  }
}
```

### Fastify Plugin

```typescript
// miso-plugin.ts
import { FastifyPluginAsync, FastifyRequest } from 'fastify';
import { MisoClient, loadConfig } from '@aifabrix/miso-client';

const misoPlugin: FastifyPluginAsync = async (fastify) => {
  const client = new MisoClient(loadConfig());
  await client.initialize();

  fastify.decorate('miso', client);

  fastify.addHook('preHandler', async (request: FastifyRequest, reply) => {
    const token = request.headers.authorization?.replace('Bearer ', '');

    if (token) {
      try {
        const isValid = await client.validateToken(token);
        if (isValid) {
          const user = await client.getUser(token);
          request.user = user;
        }
      } catch (error) {
        // Token might be invalid, continue without user
      }
    }
  });
};

// Usage
import Fastify from 'fastify';
const fastify = Fastify();
await fastify.register(misoPlugin);

fastify.get('/posts', async (request, reply) => {
  const token = request.headers.authorization?.replace('Bearer ', '');
  if (!token) {
    return reply.status(401).send({ error: 'No token provided' });
  }

  const user = await fastify.miso.getUser(token);
  return { posts: [], user };
});
```

## See Also

- [MisoClient Reference](./reference-misoclient.md) - Main client class
- [Authorization Reference](./reference-authorization.md) - Roles and permissions
- [Type Reference](./reference-types.md) - Complete type definitions
- [Examples](./examples/README.md) - Framework-specific examples
- [DataClient Reference](./reference-dataclient.md) - Browser client authentication methods
- **Example Files:**
  - [Authentication Example](../examples/step-3-authentication.ts) - Token validation and user info

---
alwaysApply: true
---
# AI Fabrix Miso Client SDK - Cursor Rules - ISO 27001 Compliant Development Standards

## Project Overview

This is the AI Fabrix Miso Client SDK - a TypeScript SDK for authentication, authorization, and logging with the Miso Controller. The SDK provides:

- **Authentication** - User login, logout, token validation, user info
- **Authorization** - Role and permission management with Redis caching
- **Logging** - ISO 27001 compliant audit logging with configurable levels
- **Data Client** - Browser-compatible HTTP client wrapper for React/front-end applications
- **Express Utilities** - Complete set of utilities for building Express.js REST APIs

Technologies:

- TypeScript (strict mode)
- Axios for HTTP communication
- ioredis for Redis caching
- jsonwebtoken for JWT token decoding (NOT verification)
- Jest for testing
- Express.js (optional peer dependency)

## Architecture Patterns

### Service Layer

- All services are in `src/services/`
- Services receive `HttpClient` and `RedisService` (or `CacheService`) as dependencies
- Services can optionally use `ApiClient` instead of direct `HttpClient` calls for typed API access
- Services use `httpClient.config` (public readonly property) for configuration access
- Services follow this pattern:

  ```typescript
  export class ServiceName {
    private httpClient: HttpClient;
    private redis: RedisService;
    private config: MisoClientConfig;
    // Optional: private apiClient: ApiClient;

    constructor(httpClient: HttpClient, redis: RedisService) {
      this.config = httpClient.config; // Access via public property
      this.httpClient = httpClient;
      this.redis = redis;
      // Optional: this.apiClient = new ApiClient(httpClient);
    }
  }
  ```

### HTTP Client Pattern

- `HttpClient` manages client token automatically via Axios interceptors
- Client token is fetched from `/api/auth/token` using `clientId` and `clientSecret`
- Client token is sent as `x-client-token` header (lowercase)
- User tokens are sent as `Authorization: Bearer <token>`
- Always use `authenticatedRequest()` for user-authenticated requests
- Use `request()` for unauthenticated requests (client token is automatic)

### API Layer Pattern

- Centralized API layer in `src/api/` provides typed interfaces for all controller API calls
- `ApiClient` wraps `HttpClient` internally and organizes APIs by domain (auth, roles, permissions, logs)
- All API classes use `HttpClient`'s `authenticatedRequest()` or `request()` methods internally
- Endpoint URLs are centralized as constants in each API class (e.g., `AUTH_LOGIN_ENDPOINT = '/api/v1/auth/login'`)
- All API request/response types use interfaces (not types) and camelCase naming convention
- Services can optionally use `ApiClient` instead of direct `HttpClient` calls (gradual migration pattern)
- API layer pattern:

  ```typescript
  export class ApiClient {
    constructor(private httpClient: HttpClient) {}
    
    readonly auth = new AuthApi(this.httpClient);
    readonly roles = new RolesApi(this.httpClient);
    readonly permissions = new PermissionsApi(this.httpClient);
    readonly logs = new LogsApi(this.httpClient);
  }

  export class AuthApi {
    private static readonly LOGIN_ENDPOINT = '/api/v1/auth/login';
    
    constructor(private httpClient: HttpClient) {}
    
    async login(params: LoginRequest, authStrategy?: AuthStrategy): Promise<LoginResponse> {
      return this.httpClient.request<LoginResponse>(
        'GET',
        AuthApi.LOGIN_ENDPOINT,
        params
      );
    }
  }
  ```

### Token Management

- **Client Token**: Automatically fetched and refreshed by `HttpClient` via interceptor
  - Fetched from `POST /api/auth/token` with `x-client-id` and `x-client-secret`
  - Stored in memory with expiration tracking
  - Added to all requests as `x-client-token` header (lowercase)
  - Refreshed automatically when expired or on 401 errors
- **User Token**: Provided by application, sent as `Authorization: Bearer <token>`
- Never expose `clientId` or `clientSecret` to the client application - only the client token

### API Endpoints

All controller endpoints use `/api` prefix:

- `/api/auth/login` - User login
- `/api/auth/logout` - User logout
- `/api/auth/validate` - Validate user token
- `/api/auth/user` - Get user info
- `/api/auth/token` - Get client token (uses x-client-id/x-client-secret)
- `/api/auth/roles` - Get user roles
- `/api/auth/roles/refresh` - Refresh user roles
- `/api/auth/permissions` - Get user permissions
- `/api/auth/permissions/refresh` - Refresh user permissions
- `/api/logs` - Send logs

### JWT Token Handling

- Always use `jsonwebtoken.decode()` (not verify - we don't have the secret)
- Extract userId from multiple possible fields: `sub`, `userId`, `user_id`, `id`
- Handle null/undefined decoded tokens gracefully
- JWT context extraction pattern:

  ```typescript
  private extractUserIdFromToken(token: string): string | null {
    try {
      const decoded = jwt.decode(token) as Record<string, unknown> | null;
      if (!decoded) return null;
      return (decoded.sub || decoded.userId || decoded.user_id || decoded.id) as string | null;
    } catch (error) {
      return null;
    }
  }
  ```

### Redis Caching Pattern

- Always check `redis.isConnected()` before using Redis
- Cache keys format: `roles:{userId}` or `permissions:{userId}`
- Cache format: `JSON.stringify({ roles: [...], timestamp: Date.now() })`
- Default TTL: 900 seconds (15 minutes)
- Always fallback to controller when Redis fails
- Pattern:

  ```typescript
  if (cacheKey && this.redis.isConnected()) {
    const cached = await this.redis.get(cacheKey);
    if (cached) {
      try {
        const parsed = JSON.parse(cached);
        return parsed.roles || [];
      } catch (error) {
        console.warn('Failed to parse cached data:', error);
      }
    }
  }
  // Fallback to controller...
  ```

## Code Style

### TypeScript Conventions

- Use `strict: true` TypeScript configuration
- Prefer interfaces over types for public APIs
- Use `public readonly` for read-only config access
- Use private methods for internal logic
- Export only what's needed in `src/index.ts`

### Naming Conventions

- **Classes**: PascalCase (`AuthService`, `HttpClient`)
- **Methods**: camelCase (`getRoles`, `validateToken`)
- **Constants**: UPPER_SNAKE_CASE
- **Private properties**: prefix with `private` keyword
- **File names**: kebab-case matching class name (`auth.service.ts`)
- **All public API outputs (types, interfaces, return values, function names) must use camelCase**
  - Type/interface properties: camelCase (`statusCode`, `correlationId`, `currentPage`, `pageSize`, `totalItems`)
  - Function names: camelCase (`transformError`, `handleApiError`, `parsePaginationParams`)
  - Return value properties: camelCase (all returned objects from SDK methods use camelCase)
  - No snake_case in public API - all outputs use camelCase convention

### Error Handling

**CRITICAL: All error handling MUST follow RFC 7807 Problem Details for HTTP APIs standard.**

#### Service Layer Error Handling

- Services should return empty arrays `[]` on errors (for get methods)
- Use try-catch for all async operations
- Log errors with `console.error` or `console.warn`
- Never throw uncaught errors from service methods
- Pattern:

  ```typescript
  try {
    // operation
  } catch (error) {
    console.error('Operation failed:', error);
    return []; // or appropriate default
  }
  ```

#### Express Route Error Handling (MANDATORY)

**✅ MANDATORY: All Express route handlers MUST use `asyncHandler()` wrapper.**

```typescript
import { Request, Response, Router } from 'express';
import { asyncHandler, AppError, handleRouteError } from '@aifabrix/miso-client';
import { MisoClient, MisoClientError } from '@aifabrix/miso-client';

const router = Router();

// Route handler with automatic error handling
router.get(
  '/api/user',
  asyncHandler(async (req: Request, res: Response): Promise<void> => {
    const token = req.headers.authorization?.replace('Bearer ', '');
    const client = new MisoClient(loadConfig());
    await client.initialize();
    
    const user = await client.getUser(token);
    res.success(user);
  }, 'getUser')
);

// Error middleware (register last)
router.use(async (error: Error, req: Request, res: Response, next: Function) => {
  await handleRouteError(error, req, res);
});

export default router;
```

**Benefits:**

- Automatic RFC 7807 error formatting
- Automatic error logging with full context
- Automatic correlation ID extraction
- Consistent error responses across all routes
- No try-catch boilerplate needed
- Sets `Content-Type: application/problem+json` header automatically

#### Using AppError for Business Logic Errors

**✅ DO: Use `AppError` for business logic errors**

```typescript
import { AppError } from '@aifabrix/miso-client';

// Simple error
if (!resource) {
  throw new AppError('Resource not found', 404);
}

// With validation errors
const errors = validateInput(data);
if (errors.length > 0) {
  throw new AppError('Validation failed', 422, true, errors);
}
```

#### Handling External API Errors (MisoClientError)

```typescript
import { MisoClientError, AppError } from '@aifabrix/miso-client';

try {
  const user = await client.getUser(token);
} catch (error) {
  if (error instanceof MisoClientError) {
    // Use structured error response if available
    if (error.errorResponse) {
      throw new AppError(
        error.errorResponse.title,
        error.errorResponse.statusCode,
        true,
        undefined,
        error.errorResponse.type,
        error.errorResponse.instance,
        error.errorResponse.correlationId
      );
    }
    // Fallback for non-structured errors
    throw new AppError(error.message, error.statusCode || 500);
  }
  throw error; // Re-throw to be handled by error middleware
}
```

#### Manual Error Logging (Non-Express)

When Express Request object is not available, include context manually:

```typescript
try {
  const result = await client.getUser(token);
} catch (error) {
  // Include all important context manually
  await client.log.error('User fetch failed', {
    // Request context
    ipAddress: '192.168.1.1',
    method: 'GET',
    path: '/api/user',
    userAgent: 'Mozilla/5.0...',
    correlationId: 'req-123',
    
    // User context
    userId: extractUserIdFromToken(token),
    
    // Error details
    statusCode: error instanceof MisoClientError ? error.statusCode : 500,
    errorMessage: error instanceof Error ? error.message : 'Unknown error',
    errorType: error instanceof MisoClientError ? error.errorResponse?.type : undefined,
    stack: error instanceof Error ? error.stack : undefined,
  });
}
```

#### MisoClientError Structure

All HTTP errors from the SDK are thrown as `MisoClientError`:

```typescript
class MisoClientError extends Error {
  readonly errorResponse?: ErrorResponse;        // Structured error (RFC 7807)
  readonly errorBody?: Record<string, unknown>;  // Raw error body (backward compatibility)
  readonly statusCode?: number;                  // HTTP status code
}
```

**Accessing error details:**

```typescript
try {
  await client.validateToken(token);
} catch (error) {
  if (error instanceof MisoClientError) {
    // Structured error response (RFC 7807)
    if (error.errorResponse) {
      console.error('Type:', error.errorResponse.type);
      console.error('Title:', error.errorResponse.title);
      console.error('Detail:', error.errorResponse.detail);
      console.error('Errors:', error.errorResponse.errors);
      console.error('Status:', error.errorResponse.statusCode);
      console.error('Correlation ID:', error.errorResponse.correlationId);
    }
    // Fallback for non-structured errors
    else if (error.errorBody) {
      console.error('Error body:', error.errorBody);
      console.error('Status:', error.statusCode);
    }
  }
}
```

#### RFC 7807 Compliance Requirements

**MANDATORY: All error responses MUST:**

- Use RFC 7807 Problem Details format
- Include `type` (URI reference, e.g., `/Errors/BadRequest`)
- Include `title` (human-readable summary)
- Include `statusCode` (HTTP status code)
- Include `detail` (human-readable explanation)
- Set `Content-Type: application/problem+json` header
- Include `correlationId` for request tracing
- Never expose stack traces or internal error details to clients

**Standard Error Type URIs:**

- `/Errors/BadRequest` - 400
- `/Errors/Unauthorized` - 401
- `/Errors/Forbidden` - 403
- `/Errors/NotFound` - 404
- `/Errors/MethodNotAllowed` - 405
- `/Errors/Conflict` - 409
- `/Errors/UnprocessableEntity` - 422
- `/Errors/TooManyRequests` - 429
- `/Errors/InternalServerError` - 500
- `/Errors/ServiceUnavailable` - 503

#### Error Logging Best Practices

**✅ Good: Comprehensive error logging with context**

The `handleRouteError()` utility automatically logs errors with full context. For manual logging:

```typescript
// Express route - use withRequest() for automatic context extraction
await client.log
  .withRequest(req)  // Auto-extracts: IP, method, path, userAgent, correlationId, userId
  .error('Operation failed', error instanceof Error ? error.stack : undefined);
```

**What `withRequest(req)` automatically extracts:**

- `ipAddress` - Client IP (handles proxy headers)
- `method` - HTTP method (GET, POST, etc.)
- `path` - Request path
- `userAgent` - Browser/client user agent
- `correlationId` - From `x-correlation-id` header
- `userId` - Extracted from JWT token
- `sessionId` - Extracted from JWT token

**❌ Bad: Minimal logging without context**

```typescript
// Don't do this - missing IP, endpoint, user, etc.
await client.log.error('Failed');  // ❌ No context!
```

**Required context for error logs:**

- IP address
- HTTP method and endpoint/path
- User ID (if available)
- Status code
- Error message and stack trace
- Correlation ID (if available)
- User agent (if available)

### Async/Await

- Always use async/await, never raw promises
- Always use try-catch with async operations
- Methods that return arrays should return empty array on error
- Methods that return objects/null should return null on error

## Testing Conventions

### Test File Structure

- Test files mirror source structure: `tests/unit/service-name.test.ts`
- Use Jest for testing
- Mock all external dependencies (axios, ioredis, jsonwebtoken)
- Mock JWT decode: `jwt.decode.mockReturnValue({ sub: '123' })`
- Test both success and error paths
- Test cache hits and misses

### Mock Patterns

- Mock HttpClient: `const mockHttpClient = { authenticatedRequest: jest.fn(), request: jest.fn() } as any;`
- Mock ApiClient: `const mockApiClient = { auth: { login: jest.fn() }, roles: { getRoles: jest.fn() } } as any;`
- Mock Redis: `const mockRedisService = { isConnected: jest.fn(), get: jest.fn(), set: jest.fn() } as any;`
- Mock JWT: `jest.mock('jsonwebtoken'); const jwt = require('jsonwebtoken');`
- Mock axios create for token fetch: Return different instance when config has `x-client-id` header

### Test Coverage

- Aim for 80%+ branch coverage
- Test edge cases (null tokens, empty arrays, cache failures)
- Test JWT decode failures
- Test Redis connection failures
- Test HTTP fallbacks

## File Organization

### Source Structure

```yaml
src/
  index.ts           # Main MisoClient class exports
  api/                # Centralized API layer (typed interfaces for controller calls)
    index.ts          # Main ApiClient class
    types/            # API request/response type definitions
    auth.api.ts       # Auth API functions
    roles.api.ts      # Roles API functions
    permissions.api.ts # Permissions API functions
    logs.api.ts       # Logs API functions
  services/          # Service layer (auth, roles, permissions, logger, redis)
  utils/             # Utilities (http-client, config-loader, data-masker)
  types/             # TypeScript type definitions
  express/           # Express.js utilities and middleware
```

### Import Order

1. External dependencies (axios, jsonwebtoken, etc.)
2. Internal types
3. Internal utilities
4. Internal API layer (if using ApiClient)
5. Internal services
6. Relative imports

### Export Strategy

- Export main class from `src/index.ts`
- Export types from `src/types/config.types.ts`
- Don't export internal utilities/services directly
- Use barrel exports only for public APIs

## Configuration

### Config Types

- All config in `src/types/config.types.ts`
- Use `loadConfig()` helper to load from .env
- Config is readonly after initialization
- Access via `httpClient.config` (public readonly)

### Environment Variables

- `MISO_CLIENTID` - Client ID
- `MISO_CLIENTSECRET` - Client secret
- `MISO_CONTROLLER_URL` - Controller base URL
- `REDIS_HOST` - Redis host (optional)
- `REDIS_PORT` - Redis port (optional)
- `MISO_LOG_LEVEL` - Logging level (optional)

## Common Patterns

### Service Method Pattern

```typescript
async getSomething(token: string): Promise<Type[]> {
  try {
    // Extract userId from token if possible
    let userId = this.extractUserIdFromToken(token);
    const cacheKey = userId ? `cache:${userId}` : null;

    // Try cache first
    if (cacheKey && this.redis.isConnected()) {
      const cached = await this.redis.get(cacheKey);
      if (cached) {
        const parsed = JSON.parse(cached);
        return parsed.data || [];
      }
    }

    // Fallback to controller
    if (!userId) {
      const userInfo = await this.httpClient.authenticatedRequest<{ user: { id: string } }>(
        'POST',
        '/api/auth/validate',
        token
      );
      userId = userInfo.user?.id || null;
      if (!userId) return [];
    }

    // Fetch from controller
    const result = await this.httpClient.authenticatedRequest<ResponseType>(
      'GET',
      '/api/endpoint',
      token
    );

    // Cache result
    if (userId && this.redis.isConnected()) {
      await this.redis.set(
        `cache:${userId}`,
        JSON.stringify({ data: result, timestamp: Date.now() }),
        this.ttl
      );
    }

    return result.data || [];
  } catch (error) {
    console.error('Operation failed:', error);
    return [];
  }
}
```

### Logger Chain Pattern

```typescript
// Fluent API
await loggerService
  .withContext({ action: 'test' })
  .withToken('jwt-token')
  .addUser('user-123')
  .info('Message');

// Error handling in logger should be silent (catch and swallow)
```

### Client Token Fetch Pattern

```typescript
// In HttpClient
private async fetchClientToken(): Promise<string> {
  // Use temporary axios instance to avoid interceptor recursion
  const tempAxios = axios.create({
    baseURL: this.config.controllerUrl,
    timeout: 30000,
    headers: {
      'Content-Type': 'application/json',
      'x-client-id': this.config.clientId,
      'x-client-secret': this.config.clientSecret
    }
  });
  
  const response = await tempAxios.post<ClientTokenResponse>('/api/auth/token');
  // Store token and expiration...
}
```

### API Layer Usage Pattern

```typescript
// Using ApiClient in services (optional, gradual migration)
export class AuthService {
  private httpClient: HttpClient;
  private apiClient: ApiClient; // Optional typed API layer

  constructor(httpClient: HttpClient, cacheService: CacheService) {
    this.httpClient = httpClient;
    this.apiClient = new ApiClient(httpClient); // Wrap HttpClient
  }

  async login(redirect: string, state?: string): Promise<LoginResponse> {
    try {
      // Option 1: Use ApiClient (typed, centralized endpoints)
      return await this.apiClient.auth.login({ redirect, state });
      
      // Option 2: Use HttpClient directly (legacy pattern, still supported)
      // return await this.httpClient.request<LoginResponse>(
      //   'GET',
      //   '/api/v1/auth/login',
      //   { redirect, state }
      // );
    } catch (error) {
      console.error('Login failed:', error);
      throw error;
    }
  }
}

// API class implementation pattern
export class AuthApi {
  // Centralize endpoint URLs as constants
  private static readonly LOGIN_ENDPOINT = '/api/v1/auth/login';
  private static readonly VALIDATE_ENDPOINT = '/api/v1/auth/validate';
  private static readonly USER_ENDPOINT = '/api/v1/auth/user';
  private static readonly LOGOUT_ENDPOINT = '/api/v1/auth/logout';

  constructor(private httpClient: HttpClient) {}

  /**
   * Login user and get login URL
   * @param params - Login request parameters
   * @param authStrategy - Optional authentication strategy override
   * @returns Login response with loginUrl and state
   */
  async login(
    params: LoginRequest,
    authStrategy?: AuthStrategy
  ): Promise<LoginResponse> {
    try {
      return await this.httpClient.request<LoginResponse>(
        'GET',
        AuthApi.LOGIN_ENDPOINT,
        params
      );
    } catch (error) {
      console.error('Login API call failed:', error);
      throw error;
    }
  }

  /**
   * Validate user token
   * @param token - User authentication token
   * @param authStrategy - Optional authentication strategy override
   * @returns Validation response with authenticated status and user info
   */
  async validateToken(
    token: string,
    authStrategy?: AuthStrategy
  ): Promise<ValidateTokenResponse> {
    try {
      return await this.httpClient.authenticatedRequest<ValidateTokenResponse>(
        'POST',
        AuthApi.VALIDATE_ENDPOINT,
        token,
        { token },
        undefined,
        authStrategy
      );
    } catch (error) {
      console.error('Token validation failed:', error);
      throw error;
    }
  }
}
```

## Security Guidelines

- Never log `clientId` or `clientSecret`
- Never expose client credentials to client-side code
- Mask sensitive data in logs (use DataMasker)
- Client token is not a Bearer token - it goes in `x-client-token` header
- User token goes in `Authorization: Bearer <token>` header

## Performance Guidelines

- Always use Redis cache when available
- Extract userId from JWT to avoid unnecessary validate API calls
- Cache roles and permissions with TTL (default 15 min)
- Use connection pooling for Redis
- Handle Redis failures gracefully with controller fallback

## Code Size Guidelines

- **File Size**: Keep source files under 500 lines
  - If a file exceeds 500 lines, consider splitting into multiple files
  - Extract related functionality into separate utility classes or modules
- **Method Size**: Keep methods under 20-30 lines
  - Break complex methods into smaller, focused helper methods
  - Each method should have a single responsibility
  - Use private helper methods to extract logic from large methods
- **Exception**: Configuration files, type definitions, and test files may exceed limits if needed

## Documentation

- Use JSDoc comments for public methods
- Include parameter types and return types in comments
- Document error conditions
- Add examples in comments for complex methods

## Dependencies

- `axios`: HTTP client
- `jsonwebtoken`: JWT decoding (NOT verification)
- `ioredis`: Redis client
- `dotenv`: Environment variable loading (dev only)

## When Adding New Features

1. Update types in `src/types/config.types.ts` first (for config) or `src/api/types/` (for API types)
2. Add API method in appropriate `src/api/*.api.ts` file if it's a controller API call
3. Add service method in `src/services/` if needed (services can use ApiClient or HttpClient)
4. Update `src/index.ts` to expose public API
5. Write comprehensive tests (mock HttpClient or ApiClient as appropriate)
6. Update documentation in `docs/`
7. Maintain 80%+ branch coverage

## Critical Rules

### Must Do (✅)

- ✅ Always use `/api` prefix for controller endpoints
- ✅ Client token: `x-client-token` header (lowercase)
- ✅ User token: `Authorization: Bearer <token>`
- ✅ Extract userId from JWT before calling validate when possible
- ✅ Always check `redis.isConnected()` before Redis operations
- ✅ Return empty array `[]` on service method errors
- ✅ Use public readonly `config` property, not private
- ✅ Mock JWT decode in tests: `jwt.decode.mockReturnValue({ sub: '123' })`
- ✅ Use temporary axios instance for client token fetch (avoid recursion)
- ✅ All public API outputs use camelCase (no snake_case)
- ✅ Centralize endpoint URLs as constants in API classes (e.g., `AUTH_LOGIN_ENDPOINT`)
- ✅ Use interfaces (not types) for API request/response types
- ✅ Add JSDoc comments for all public API methods with parameter types and return types
- ✅ **MANDATORY: All Express route handlers MUST use `asyncHandler()` wrapper**
- ✅ **MANDATORY: All error responses MUST follow RFC 7807 Problem Details format**
- ✅ **MANDATORY: All error responses MUST set `Content-Type: application/problem+json` header**
- ✅ **MANDATORY: Use `handleRouteError()` for Express error middleware**
- ✅ **MANDATORY: Use `AppError` for business logic errors**
- ✅ Always log errors with comprehensive context (IP, endpoint, user, status code, stack trace)
- ✅ Use `withRequest(req)` in Express routes for automatic context extraction
- ✅ Handle `MisoClientError` with structured error responses (check `errorResponse` property)
- ✅ Include correlation IDs in error responses (automatic via `handleRouteError`)
- ✅ Use standard error type URIs (`/Errors/{ErrorType}`)

### Must Not Do (❌)

- ❌ Never expose `clientId` or `clientSecret` in client code
- ❌ Never throw uncaught errors from service methods
- ❌ Never use `X-Client-Token` (use lowercase `x-client-token`)
- ❌ Don't verify JWT tokens (only decode - no secret available)
- ❌ Don't use snake_case in public API outputs
- ❌ Don't skip Redis connection checks
- ❌ Don't skip error handling in async operations
- ❌ Don't log sensitive data without masking
- ❌ Don't hardcode endpoint URLs in API methods (use constants)
- ❌ Don't use types instead of interfaces for public API definitions
- ❌ **NEVER use try-catch in Express route handlers (use `asyncHandler` instead)**
- ❌ **NEVER expose stack traces or internal error details to clients**
- ❌ **NEVER use old error formats (must use RFC 7807 format)**
- ❌ **NEVER skip error middleware registration (must use `handleRouteError`)**
- ❌ Don't log errors without context (always include IP, endpoint, user, status code)
- ❌ Don't ignore `MisoClientError.errorResponse` - always check for structured errors first
- ❌ Don't skip correlation IDs in error responses

---

**Remember**: Security is not optional. Every line of code must be written with security and compliance in mind. When in doubt, choose the more secure option and document the decision.

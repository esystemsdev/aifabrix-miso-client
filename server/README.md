# Miso Test Application

Production-ready demonstration application showcasing all DataClient capabilities from the AI Fabrix Miso Client SDK.

## Overview

This application demonstrates all features of the DataClient, including:

- **Authentication** - `isAuthenticated()`, `redirectToLogin()`, `logout()`, `getEnvironmentToken()`, `getClientTokenInfo()`
- **HTTP Methods** - `get()`, `post()`, `put()`, `patch()`, `delete()`
- **Caching** - Cache configuration, `clearCache()`, cache TTL
- **Retry Logic** - Automatic retry with exponential backoff
- **Interceptors** - Request, response, and error interceptors
- **Metrics** - Request metrics tracking (`getMetrics()`)
- **Audit Logging** - ISO 27001 compliant audit logging
- **Error Handling** - Network errors, timeouts, API errors

## Features

### Browser-Safe Implementation

✅ **No `clientSecret` in browser code** - Uses server-provided client token pattern  
✅ **Proper CORS configuration** - Origin validation with `MISO_ALLOWED_ORIGINS`  
✅ **Comprehensive error handling** - Try-catch for all async operations  
✅ **Production-ready** - Error handling, logging, security best practices

## Quick Start

### Prerequisites

- Node.js 18+ and npm
- Miso Controller running (for authentication)
- Environment variables configured (see Configuration section)

### Installation

```bash
# Install dependencies
cd server
npm install
```

### Configuration

The `.env` file is automatically generated by the builder. Use the builder to generate it:

```bash
# Generate .env file from builder configuration
cd ..
aifabrix resolve miso-test
```

This will create a `.env` file in the project root (or path specified in `builder/miso-test/variables.yaml` → `build.envOutputPath`).

**Note:** The server automatically loads the `.env` file from the root directory. When running from the `server/` directory, it will look for `.env` in the parent directory (root) first, then fall back to `server/.env` if not found. This matches the builder's default output path.

**Environment Variables:**

The builder generates these variables from `builder/miso-test/env.template`:

- `PORT` - Server port (default: 3083)
- `NODE_ENV` - Environment (development/production)
- `MISO_CONTROLLER_URL` - Controller URL
- `MISO_CLIENTID` - Client ID (from secrets)
- `MISO_CLIENTSECRET` - Client secret (from secrets)
- `MISO_ALLOWED_ORIGINS` - CORS allowed origins
- `MISO_LOG_LEVEL` - Logging level (optional)

**First Time Setup:**

If you haven't registered the application yet:

```bash
# Login to controller
aifabrix login --method device --environment dev --controller http://localhost:3000 --offline

# Register your application (gets you credentials automatically)
aifabrix app register miso-test --environment dev

# Then generate .env file
aifabrix resolve miso-test
```

See `builder/miso-test/README.md` for complete setup instructions.

### Running the Application

```bash
# Development mode (with hot reload)
npm run dev

# Production mode
npm run build
npm start
```

The application will be available at:

- **Demo Page**: <http://localhost:3083/>
- **Health Check**: <http://localhost:3083/health>
- **API Base**: <http://localhost:3083/api>

## API Endpoints

### Health Check

```text
GET /health
```

Returns server status and uptime.

### Client Token Endpoint

```text
POST /api/v1/auth/client-token
```

Server-side endpoint that provides client tokens to the browser. Uses the zero-config `createClientTokenEndpoint` helper which:

- Validates request origin
- Fetches client token from controller
- **Automatically enriches response with DataClient configuration** (baseUrl, controllerUrl, clientId, etc.)

**Response format:**

```json
{
  "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "expiresIn": 1800,
  "config": {
    "baseUrl": "http://localhost:3083",
    "controllerUrl": "https://controller.aifabrix.ai",
    "controllerPublicUrl": "https://controller.aifabrix.ai",
    "clientId": "ctrl-dev-my-app",
    "clientTokenUri": "/api/v1/auth/client-token"
  }
}
```

This allows browser clients to use `autoInitializeDataClient()` for zero-config initialization.

### Mock API Endpoints

The following endpoints are provided for testing DataClient features:

- `GET /api/users` - List all users (demonstrates GET with caching)
- `GET /api/users/:id` - Get user by ID
- `POST /api/users` - Create user (demonstrates POST)
- `PUT /api/users/:id` - Update user (demonstrates PUT)
- `PATCH /api/users/:id` - Partial update (demonstrates PATCH)
- `DELETE /api/users/:id` - Delete user (demonstrates DELETE)
- `GET /api/metrics` - Return mock metrics
- `GET /api/slow?delay=5000` - Slow endpoint (for timeout/retry testing)
- `GET /api/error/:code` - Error endpoint (for error handling testing)

## DataClient Features Demonstrated

### Authentication & Authorization

- **`isAuthenticated()`** - Check if user is authenticated
- **`redirectToLogin()`** - Redirect to login flow via controller
- **`logout()`** - Logout user and clear tokens
- **`getEnvironmentToken()`** - Get client token (with caching)
- **`getClientTokenInfo()`** - Extract token information

### HTTP Methods

All standard HTTP methods are demonstrated:

- `get()` - With caching options
- `post()` - With data and options
- `put()` - Full resource update
- `patch()` - Partial update
- `delete()` - Resource deletion

### Advanced Features

#### Caching

- Enable/disable caching per request
- Custom TTL (Time To Live)
- Cache keys
- `clearCache()` method

#### Retry Logic

- Automatic retry with exponential backoff
- Configurable retry count
- Retryable vs non-retryable errors

#### Interceptors

- **Request Interceptor** - Transform requests before sending
- **Response Interceptor** - Transform responses after receiving
- **Error Interceptor** - Handle errors globally

#### Metrics

- `getMetrics()` - Get request metrics
- Total requests, failures, response times
- Cache hit rate
- Error rate
- Response time distribution

#### Audit Logging

- ISO 27001 compliant audit logging
- Configurable audit levels (minimal, standard, detailed, full)
- Automatic sensitive data masking
- Skip endpoints configuration

#### Error Handling

- Network errors
- Timeout errors
- API errors (4xx, 5xx)
- Proper error types and messages

## Project Structure

```text
server/
├── src/
│   ├── server.ts              # Main Express server
│   ├── routes/
│   │   ├── api.ts            # API endpoints (factory function pattern)
│   │   └── health.ts         # Health check endpoint (factory function pattern)
│   ├── middleware/
│   │   ├── cors.ts           # CORS middleware
│   │   └── error-handler.ts  # Error handling middleware
│   └── config/
│       └── env.ts            # Environment configuration
├── public/
│   ├── index.html            # Demo UI page
│   ├── assets/
│   │   └── app.js           # Frontend JavaScript
│   └── styles.css            # UI styling
├── dist/                     # Compiled output
├── package.json              # Dependencies
├── tsconfig.json             # TypeScript configuration
└── README.md                 # This file
```

## Route Handler Pattern

This server uses a **factory function pattern** for route handlers that allows dependency injection of MisoClient while maintaining clean route definitions.

### Pattern Overview

Route handlers are factory functions that:
1. Accept `misoClient: MisoClient | null` as a parameter
2. Return an `asyncHandler()`-wrapped route handler
3. Use MisoClient for logging and error handling

### Example

```typescript
import { Request, Response } from 'express';
import { MisoClient, asyncHandler, AppError } from '@aifabrix/miso-client';

// Factory function: Accept misoClient, return route handler
export function getUsers(misoClient: MisoClient | null) {
  return asyncHandler(async (req: Request, res: Response): Promise<void> => {
    // Log using MisoClient logger if available
    if (misoClient) {
      await misoClient.log.forRequest(req).info('Fetching users list');
    }
    
    const users = await fetchUsers();
    res.json({ users, count: users.length });
  }, 'getUsers'); // Operation name for error tracking
}

// Register route with factory function
app.get('/api/users', getUsers(misoClient));
```

### Benefits

- **Dependency Injection**: MisoClient injected at route registration, not hardcoded
- **Automatic Error Handling**: `asyncHandler()` wraps handlers for RFC 7807 error formatting
- **Automatic Logging**: Request context (IP, method, path, correlationId, userId) auto-extracted
- **No Try-Catch Boilerplate**: `asyncHandler()` eliminates manual error handling
- **Operation Tracking**: Operation names help track errors in logs

### Error Handling

All route handlers use `asyncHandler()` which:
- Automatically catches errors
- Formats errors as RFC 7807 Problem Details
- Logs errors with full context via configured error logger
- Extracts correlation IDs automatically

Business logic errors should throw `AppError`:

```typescript
if (!user) {
  if (misoClient) {
    await misoClient.log
      .forRequest(req)
      .addContext('level', 'warning')
      .info(`User not found: ${id}`);
  }
  throw new AppError('User not found', 404);
}
```

### Logging

Use `misoClient.log.forRequest(req)` for automatic context extraction:

```typescript
// Automatic context: IP, method, path, userAgent, correlationId, userId
if (misoClient) {
  await misoClient.log.forRequest(req).info('Operation message');
}

// Add additional context
if (misoClient) {
  await misoClient.log
    .forRequest(req)
    .addContext('userId', userId)
    .addContext('action', 'update')
    .info('User updated');
}
```

**See Also:**

- [Express Examples](../../docs/examples.md#factory-function-pattern-for-route-handlers) - Complete factory function pattern guide
- [Error Handling Reference](../../docs/reference-errors.md) - Error handling best practices

### Error Logger Configuration

The server configures error logging after MisoClient initialization to use MisoClient logger with automatic request context extraction.

**Configuration Pattern:**

```typescript
misoClient.initialize()
  .then(async () => {
    // Configure error logger to use MisoClient logger with forRequest()
    setErrorLogger({
      async logError(message, options) {
        const req = (options as { req?: Request })?.req;
        if (req && misoClient) {
          // Use forRequest() for automatic context extraction
          await misoClient.log
            .forRequest(req)
            .error(message, (options as { stack?: string })?.stack);
        } else if (misoClient) {
          // Fallback for non-Express contexts
          await misoClient.log.error(message, options as Record<string, unknown>);
        } else {
          // Final fallback to console if MisoClient not available
          console.error('[ERROR]', message);
          if ((options as { stack?: string })?.stack) {
            console.error('[ERROR] Stack:', (options as { stack?: string }).stack);
          }
        }
      }
    });
  });
```

**Benefits:**

- Automatic request context extraction (IP, method, path, correlationId, userId)
- RFC 7807 compliant error logging
- Graceful fallback when MisoClient unavailable
- ISO 27001 compliant audit logging

### MisoClient Fallback Behavior

The server gracefully handles scenarios where MisoClient is not initialized or unavailable:

**Fallback Patterns:**

1. **Route Handlers**: All route handlers accept `misoClient: MisoClient | null` and check before logging
2. **Logging**: Logging calls are conditional (`if (misoClient) { ... }`)
3. **Error Logger**: Error logger has multiple fallback levels (MisoClient → console)
4. **Startup**: Server starts immediately, MisoClient initializes asynchronously

**Example Fallback in Route Handler:**

```typescript
export function getUsers(misoClient: MisoClient | null) {
  return asyncHandler(async (req: Request, res: Response): Promise<void> => {
    // Conditional logging - works with or without MisoClient
    if (misoClient) {
      await misoClient.log.forRequest(req).info('Fetching users list');
    }
    
    // Business logic continues regardless of MisoClient availability
    const users = await fetchUsers();
    res.json({ users, count: users.length });
  }, 'getUsers');
}
```

**Benefits:**

- Server starts even if MisoClient initialization fails
- Routes continue to function without MisoClient
- Logging is optional, not required
- Graceful degradation for development/testing

## Testing

### Test Structure

Tests are located in `src/__tests__/` and mirror the source structure:

- `api.test.ts` - API route handler tests
- `health.test.ts` - Health check tests
- `middleware/error-handler.test.ts` - Error middleware tests
- `middleware/cors.test.ts` - CORS middleware tests
- `error-logger.test.ts` - Error logger configuration tests
- `miso-client-fallback.test.ts` - MisoClient fallback behavior tests
- `server.integration.test.ts` - Integration tests
- `server.logging.test.ts` - Logging endpoint tests

### Test Patterns

**Testing Route Handlers:**

```typescript
import { getUsers } from '../routes/api';
import { MisoClient } from '@aifabrix/miso-client';

describe('getUsers', () => {
  it('should work with null MisoClient', async () => {
    const handler = getUsers(null);
    await handler(mockRequest, mockResponse, mockNext);
    
    expect(mockResponse.json).toHaveBeenCalled();
  });

  it('should log when MisoClient is available', async () => {
    const mockMisoClient = {
      log: {
        forRequest: jest.fn().mockReturnValue({
          info: jest.fn().mockResolvedValue(undefined),
        }),
      },
    } as unknown as MisoClient;

    const handler = getUsers(mockMisoClient);
    await handler(mockRequest, mockResponse, mockNext);

    expect(mockMisoClient.log.forRequest).toHaveBeenCalled();
  });
});
```

**Testing Error Logger Configuration:**

```typescript
import { setErrorLogger } from '@aifabrix/miso-client';

describe('Error Logger', () => {
  it('should use forRequest() when request is available', async () => {
    const errorLogger = {
      async logError(message, options) {
        const req = (options as { req?: Request })?.req;
        if (req && misoClient) {
          await misoClient.log.forRequest(req).error(message, options.stack);
        }
      },
    };

    setErrorLogger(errorLogger);
    // Test error logging...
  });
});
```

**Testing Fallback Behavior:**

```typescript
describe('MisoClient Fallback', () => {
  it('should handle null MisoClient gracefully', async () => {
    const handler = getUsers(null);
    await handler(mockRequest, mockResponse, mockNext);
    
    // Should complete successfully without logging
    expect(mockResponse.json).toHaveBeenCalled();
  });
});
```

### Running Tests

```bash
# Run all tests
npm test

# Run specific test file
npm test -- error-logger.test.ts

# Run tests in watch mode
npm test -- --watch
```

## Development

### Scripts

- `npm run dev` - Run in development mode with ts-node
- `npm run build` - Compile TypeScript to JavaScript
- `npm start` - Run compiled JavaScript
- `npm test` - Run tests
- `npm run lint` - Lint code
- `npm run lint:fix` - Fix linting issues

### Building

```bash
npm run build
```

This compiles TypeScript files to the `dist/` directory.

### Testing

```bash
npm test
```

## Security Considerations

### Browser Safety

⚠️ **IMPORTANT**: Never expose `clientSecret` in browser/client-side code.

This application uses the **Server-Provided Client Token Pattern**:

1. Browser requests client token from server endpoint (`/api/v1/auth/client-token`)
2. Server validates origin and returns client token
3. DataClient uses client token for authentication
4. Client token is cached in localStorage

### CORS Configuration

Configure `MISO_ALLOWED_ORIGINS` to restrict which origins can access the API:

```env
MISO_ALLOWED_ORIGINS=http://localhost:3083,https://myapp.com
```

Use wildcards for ports in development:

```text
MISO_ALLOWED_ORIGINS=http://localhost:*
```

## Troubleshooting

### DataClient Not Loading

If DataClient fails to load:

1. Ensure parent package is built: `npm run build` (in root directory)
2. Check browser console for errors
3. Verify `/dataclient.js` endpoint is accessible

### CORS Errors

If you see CORS errors:

1. Check `MISO_ALLOWED_ORIGINS` includes your origin
2. Verify origin header is being sent correctly
3. Check server logs for origin validation errors

### Authentication Errors

If authentication fails:

1. Verify `MISO_CONTROLLER_URL` is correct
2. Check `MISO_CLIENTID` and `MISO_CLIENTSECRET` are set (from builder secrets)
3. Ensure Miso Controller is running and accessible
4. Check server logs for detailed error messages
5. Regenerate `.env` file: `aifabrix resolve miso-test`

### Port Already in Use

If port 3083 is already in use:

1. Change `port` in `builder/miso-test/variables.yaml`
2. Regenerate `.env` file: `aifabrix resolve miso-test`
3. Update `baseUrl` in the demo UI accordingly

## Integration with Builder

This application is standalone and independent from the builder. The builder (`@aifabrix/builder`) is only used for deployment:

```bash
# Build Docker image
aifabrix build miso-test

# Deploy to Azure
aifabrix deploy miso-test --controller https://controller.aifabrix.ai --environment dev
```

See `builder/miso-test/README.md` for complete deployment instructions.

## License

MIT

## Support

For issues and questions, see:

- [Main SDK documentation](../../docs/)
- [DataClient documentation](../../docs/data-client.md)
- [GitHub Issues](https://github.com/esystemsdev/aifabrix-miso-client/issues)
